<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.30 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>

<rfc ipr="trust200902" docName="draft-jimenez-supei-00" category="info">

  <front>
    <title abbrev="SUPEI">Software Upgrade Experiences for IoT</title>

    <author initials="J." surname="Jimenez" fullname="Jaime Jimenez">
      <organization>Ericsson</organization>
      <address>
        <email>jaime.jimenez@ericsson.com</email>
      </address>
    </author>
    <author initials="M." surname="Ocak" fullname="Mert Ocak">
      <organization>Ericsson</organization>
      <address>
        <email>mert.ocak@ericsson.com</email>
      </address>
    </author>

    <date year="2016" month="May" day="30"/>

    
    
    

    <abstract>


<t>This document provides a summary of found problems and possible solutions for software upgrades on the constrained space. Some of the issues are still open and should be subject of discussion. Ideally some implementation guidelines should be made when using CoAP <xref target="RFC7252"/>, HTTP <xref target="RFC7230"/> or MQTT as transfer protocols.</t>



    </abstract>


  </front>

  <middle>


<section anchor="introduction" title="Introduction">

<t>In this short paper we try to raise some issues we have found when dealing with software upgrades in the IoT domain. Dealing with sleepy endpoint is at <xref target="sleepy"/>. The case for device initiated communication is on <xref target="devini"/> and manager initiated on <xref target="serverini"/>. Delegation on gateways or other nodes is in <xref target="delegation"/>. The use of an alternative stack for software upgrades is at <xref target="many"/>. A possible long-term architecture that enables to do runtime updates on the constrained device is at <xref target="run"/></t>

</section>
<section anchor="architecture" title="Architecture">

<t>Ideally our target CoAP stack is the following:</t>

<figure><artwork><![CDATA[
     Device                                         Manager
 +-------------------+                      +-------------------+
 |CoAP Server/Client | +----------------->  |CoAP Server/Client |
 +-------------------+                      +-------------------+
 |IPv4/IPv6 - UDP    |                      |IPv4/IPv6 - UDP    |
 +-------------------+ <-----------------+  |                   |
 |GSM/3G             |                      |                   |
 +-------------------+                      +-------------------+
]]></artwork></figure>

<t>This set up poses several issues when dealing with the operator environment.</t>

<t><spanx style="strong">JAIME:</spanx> Could the image be improved somehow? Is it sufficient?</t>

</section>
<section anchor="sleepy" title="Dealing with Sleepy endpoints">

<t>The fact that devices are sleepy poses several problems for doing software updates. Namely that you do not have a connected endpoint most of the time and that therefore the device will have to contact the manager or the manager will have to poll the device pretty frequently. The case for polling does not scale and therefore it is hardly a solution.</t>

<t>Nevertheless it is very common to use polling on the constrained space since the server has more capabilities and thus can query the device providing that there are no NATs or firewalls (See <xref target="devini"/>)</t>

</section>
<section anchor="devini" title="Device Initiated Communication">

<t>The first issue are NATs and Firewalls. Constrained devices do not have the capabilities nor the inclination to punch holes through NATs and keep them open, that task has to be delegated elsewhere.</t>

<t>What we have done in order to overcome this obstacle is to set an observation on the device. Assuming that the device has previously registered on a Resource Directory (RD) <xref target="I-D.ietf-core-resource-directory"/> that the manager has access to, the manager would then observe the status of the device (0:off, 1:on). Whenever the device wakes up it will send a notification to the manager. During the time the NAT is open the manager will be able to send data through the holes in the NAT.</t>

<figure><artwork><![CDATA[
D<--M: CoAP GET /Radio_link_status, Token: 0x4a, Observe: 0  
D-->M: 2.05 Content, Token: 0x4a, payload: 1, time: 1464619477
D-->M: 2.05 Content, Token: 0x4a, payload: 1, time: 1464520998
]]></artwork></figure>

</section>
<section anchor="serverini" title="Manager Initiated Communication">
<t>NATs and Firewalls are persistent issues to resolve also in manager initiated communication. However, we could re-use the capabilities of CoAP to overcome this issue.</t>

<t>In this approach, there is no need to set a separate observation on the status of the device as defined in <xref target="devini"/>. When the device sends a notification to any existing observation on any resource, the manager can initiate the software update during the established connection through NAT. This approach requires the manager to implement the logic of linking observation of any resource to send software update to the device.</t>

</section>
<section anchor="delegation" title="Delegation on other nodes">

<t>Many of the IoT devices may not have connectivity to the manager and gateways are used to provide such connectivity to the manager in the e.g. core network. Gateways used in this use case are more capable to perform complex operations and to support different protocol stacks together, which can be used to update the device software.</t>

<t>For our implementation we assumed that the gateway supports, at least, both CoAP and HTTP stacks. The communication between the device and the gateway is performed using CoAP. Gateways can retrieve the software update from the manager through HTTP without NAT issues and cache the package. When the device wakes up and connects to the gateway, the gateway can push the software update to the device.</t>

<t>However, this approach requires the Gateway to have the required credentials to perform such software update operation. This can be achieved e.g. by having a CoAP proxy on the Gateway.</t>

<t><spanx style="strong">JAIME:</spanx> Could you add an example here? Some sequence diagram as in <xref target="devini"/>, code sniplet…</t>

</section>
<section anchor="many" title="Using Multiple Stacks">

<t>We have seen how in some cases devices have multiple stack combinations and updates go through an “alternative channel”. For example:</t>

<t><list style="hanging">
  <t hangText='MQTT+HTTP'>
  in this scenario MQTT is used as the base protocol for communication. Having publish/subscribe architecture simplifies the (1:n) and (n:1) communication use cases that are very common for reporting sensor data. For firmware upgrades a command is sent to the device with the URL where the new binaries are (i.e. https://company/devicetype/version00.zip), the device then sets a whole different communication channel just for that, as well as a dedicated DTLS/TLS connection. This is too much overhead for many constrained devices.</t>
</list></t>

<t><spanx style="strong">JAIME:</spanx> We need another example here, any ideas?.</t>

</section>
<section anchor="possible-ddos" title="Possible DDOS">

<t>TBD</t>

<t><spanx style="strong">JAIME:</spanx> When I thought of software update issues, I firstly thought of DDoS generated by the billions of devices on the CDN hosting the updates. So I am wondering if that is a non issue?</t>

<t><spanx style="strong">MERT:</spanx> Isn’t software update server controlled i.e. how would DDOS work if server already controls the update process? I mean, e.g. can a device request its software to be updated from the server?</t>

<t><spanx style="strong">JAIME:</spanx> I guess the point here is if there are some issues with updating ALL devices at once, specially if there are billions of them… anyway we could remove this part cause I am not sure about its usefullness.</t>

</section>
<section anchor="run" title="Runtime Discovery">

<t>Instead of sending bulk binaries with several megabytes of data, a simpler approach would be to send partial modifications related to the software update when possible.</t>

<t>Similarly as it was shown in the IOTSI Workshop <xref target="IOTSIWS"/>, Runtime Discovery is also a very powerful mechanism to provide updated services and software to a device.</t>

<t>A device could use a single entry point for its firmware information (e.g. “/fw”), then device would periodically perform discovery on that point and in order to discover new capabilities. Links to the new capabilities could be discoverable on demand. Only very basic semantics would be shared a-priori.</t>

<t>Current software upgrade mechanism do not allow for changes at runtime. There are predefined interfaces that would break whenever the API changes, making it compulsory to send new software to the device that would need to install it, reboot, etc. The device logic has to support such interfaces, no changes are possible at runtime.</t>

</section>
<section anchor="acknowledgements" title="Acknowledgements">

<t>Runtime Discovery ideas are inspired from Matthias Kovatsch’s presentations on HATEOAS at <xref target="IOTSIWS"/>. Thanks to Carsten Bormann for the valuable feedback.</t>

</section>


  </middle>

  <back>


    <references title='Informative References'>





<reference  anchor='RFC7252' target='http://www.rfc-editor.org/info/rfc7252'>
<front>
<title>The Constrained Application Protocol (CoAP)</title>
<author initials='Z.' surname='Shelby' fullname='Z. Shelby'><organization /></author>
<author initials='K.' surname='Hartke' fullname='K. Hartke'><organization /></author>
<author initials='C.' surname='Bormann' fullname='C. Bormann'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Constrained Application Protocol (CoAP) is a specialized web transfer protocol for use with constrained nodes and constrained (e.g., low-power, lossy) networks.  The nodes often have 8-bit microcontrollers with small amounts of ROM and RAM, while constrained networks such as IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs) often have high packet error rates and a typical throughput of 10s of kbit/s.  The protocol is designed for machine- to-machine (M2M) applications such as smart energy and building automation.</t><t>CoAP provides a request/response interaction model between application endpoints, supports built-in discovery of services and resources, and includes key concepts of the Web such as URIs and Internet media types.  CoAP is designed to easily interface with HTTP for integration with the Web while meeting specialized requirements such as multicast support, very low overhead, and simplicity for constrained environments.</t></abstract>
</front>
<seriesInfo name='RFC' value='7252'/>
<seriesInfo name='DOI' value='10.17487/RFC7252'/>
</reference>



<reference  anchor='RFC7230' target='http://www.rfc-editor.org/info/rfc7230'>
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials='R.' surname='Fielding' fullname='R. Fielding' role='editor'><organization /></author>
<author initials='J.' surname='Reschke' fullname='J. Reschke' role='editor'><organization /></author>
<date year='2014' month='June' />
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name='RFC' value='7230'/>
<seriesInfo name='DOI' value='10.17487/RFC7230'/>
</reference>



<reference anchor='I-D.ietf-core-resource-directory'>
<front>
<title>CoRE Resource Directory</title>

<author initials='Z' surname='Shelby' fullname='Zach Shelby'>
    <organization />
</author>

<author initials='M' surname='Koster' fullname='Michael Koster'>
    <organization />
</author>

<author initials='C' surname='Bormann' fullname='Carsten Bormann'>
    <organization />
</author>

<author initials='P' surname='Stok' fullname='Peter Van der Stok'>
    <organization />
</author>

<date month='March' day='21' year='2016' />

<abstract><t>In many M2M applications, direct discovery of resources is not practical due to sleeping nodes, disperse networks, or networks where multicast traffic is inefficient.  These problems can be solved by employing an entity called a Resource Directory (RD), which hosts descriptions of resources held on other servers, allowing lookups to be performed for those resources.  This document specifies the web interfaces that a Resource Directory supports in order for web servers to discover the RD and to register, maintain, lookup and remove resources descriptions.  Furthermore, new link attributes useful in conjunction with an RD are defined.</t></abstract>

</front>

<seriesInfo name='Internet-Draft' value='draft-ietf-core-resource-directory-07' />
<format type='TXT'
        target='http://www.ietf.org/internet-drafts/draft-ietf-core-resource-directory-07.txt' />
</reference>


<reference anchor="IOTSIWS" target="https://www.iab.org/activities/workshops/iotsi/">
  <front>
    <title>IoT Workshop for Semantic Interoperability (IOTSI) - Main Page and Position Papers</title>
    <author >
      <organization>IAB</organization>
    </author>
    <date year="2016"/>
  </front>
</reference>


    </references>



  </back>
</rfc>

