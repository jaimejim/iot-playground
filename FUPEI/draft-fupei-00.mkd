---
title: Firmware Upgrade Experiences for IoT
abbrev: FUPEI
docname: draft-fupei-00
date: 2016-05-30
category: info

ipr: trust200902
area:

stand_alone: yes
pi: [toc, sortrefs, symrefs]

author:
 -
    ins: J. Jimenez
    name: Jaime Jimenez
    organization: Ericsson
    email: jaime.jimenez@ericsson.com

normative:

informative:
  RFC7252:
  RFC7230:
  I-D.ietf-core-resource-directory:
  IOTSIWS:
    title: IoT Workshop for Semantic Interoperability (IOTSI) - Main Page and Position Papers
    author: 
      org: IAB
    date: 2016
    target: https://www.iab.org/activities/workshops/iotsi/


--- abstract
This document provides a summary of found problems and possible solutions for firmware upgrades on the constrained space. Some of the issues are still open and should be subject of discussion. Ideally some implementation guidelines should be made when using CoAP {{RFC7252}}, HTTP {{RFC7230}} or MQTT as transport.

--- middle

Introduction
============

Architecture
============

Ideally our target CoAP stack is the following:


         Device                                         Manager
     +-------------------+                      +-------------------+
     |CoAP Server/Client | +----------------->  |CoAP Server/Client |
     +-------------------+                      +-------------------+
     |IPv4/IPv6 - UDP    |                      |IPv4/IPv6 - UDP    |
     +-------------------+ <-----------------+  |                   |
     |GSM/3G             |                      |                   |
     +-------------------+                      +-------------------+

This set up poses several issues when dealing with the operator environment.


Device Initiated Communication
==============================

The first issue are NATs and Firewalls. Constrained devices do not have the capabilities nor the inclination to punch holes through NATs and keep them open, that task has to be delegated elsewhere. 

What we have done in order to overcome this obstacle is to set an observation on the device. Assuming that the device has previously registered on a Resource Directory (RD) {{I-D.ietf-core-resource-directory}} that the manager has access to, the manager would then observe the status of the device (0:off, 1:on). Whenever the device wakes up it will send a notification to the manager. During the time the NAT is open the manager will be able to send data through the holes in the NAT.

~~~~~~~~~~~
D<--M: CoAP GET /Radio_link_status, Token: 0x4a, Observe: 0  
D-->M: 2.05 Content, Token: 0x4a, payload: 1, time: 1464619477
D-->M: 2.05 Content, Token: 0x4a, payload: 1, time: 1464520998
~~~~~~~~~~~


Using Multiple Stacks
=====================

We have seen how in some cases devices have multiple stack combinations and firmware software goes through an "alternative channel". For example:

MQTT+HTTP
: in this scenario MQTT is used as the base protocol for communication. Having publish/subscribe architecture simplifies the (1:n) and (n:1) communication use cases that are very common for reporting sensor data. For firmware upgrades a command is sent to the device with the URL where the new binaries are (i.e. https://company/devicetype/version00.zip), the device then sets a whole different communication channel just for that, as well as a dedicated DTLS/TLS connection. This is too much overhead for many constrained devices. 


Runtime Discovery
=================

Instead of sending bulk binaries with several megabytes of data, a simpler approach would be to send partial modifications related to firmware when possible. 

Similarly as it was shown in the IOTSI Workshop {{IOTSIWS}}, Runtime Discovery is also a very powerful mechanism to provide updated services and software to a device.

A device could use a single entry point for its firmware information (e.g. "/fw"), then device would periodically perform discovery on that point and in order to discover new capabilities. Links to the new capabilities could be discoverable on demand. Only very basic semantics would be shared a-priori.

Current firmware upgrade mechanism do not allow for changes at runtime. There are predefined interfaces that would break whenever the API changes, making it compulsory to send new software to the device that would need to install it, reboot, etc. The device logic has to support such interfaces, no changes are possible at runtime. 


Acknowledgements
=================


